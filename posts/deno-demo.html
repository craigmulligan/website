<p>Iâ€™ve been following <a href=https://deno.land>deno</a> from a far for a while now, Iâ€™m particularly interested in it for two reasons.<ol><li>First class typescript support - I hate having to compile things with babel or webpack and then having to run them via node in production it always ends-up being a little brittle & complicated with everyone having their own home grown scripts and workflows for dev and production.<li>Compiled executables - Scripting languages are really neat for making little tools, but they are pretty hard to distribute. For that reason Iâ€™ve been using Go for <a href=/#tools>small utilities</a>, but Iâ€™d much prefer to write these tools in something like python or javascript.</ol><p>So I thought Iâ€™d dip my toes in and see how a packaged app would look. Deno has fairly unique dependency story compared to javascriptâ€™s npm ecosystem. It pulls dependencies from remote urls on first run and then caches them until you clear the cache, very similar to how a browser loads a webpages dependencies.<blockquote><p>If you want to skip the rest and just check out the code it can be found ðŸ‘‰ <a href=https://github.com/hobochild/deno-demo>here</a></blockquote><p>The first thing to figure out was how to create a reproducible build, turned out to be fairly easy you can create a lock file with:<pre><code class=language-sh><pre style=background-color:#fff>deno cache --lock<span style=color:#000;font-weight:bold>=</span>lock.json --lock-write src/deps.ts
</pre></code></pre><p>And then install with that lock file using:<pre><code class=language-sh><pre style=background-color:#fff>deno cache --reload --lock<span style=color:#000;font-weight:bold>=</span>lock.json src/deps.ts
</pre></code></pre><p>The next was how to make that build as small as possible, I did this by using denoâ€™s compile feature which can cross-compile standalone binaries (quite similar to vercelâ€™s <a href=https://www.npmjs.com/package/pkg>pkg</a>). The linux executable is dynamically linked with <code>glibc</code> so youâ€™ll that present, luckily most systems have this. I unfortunately encountered the issue because I tried to use the vanilla apline image.<p>The results:<p><a href=https://github.com/hobochild/deno-demo>The code</a> is fairly self explanatory. Itâ€™s a <a href=https://github.com/hobochild/deno-demo/Dockerfile>multi-stage docker build</a> for a bare-bones <code>oak</code> server (comparable to node.jsâ€™s express). There are 3 useful make targets.<ol><li><code>make size_uncompressed</code> - this will give you the ondisk size of the image.</ol><p>The on disk size comes out a <strong>53.3mb</strong> (30mb of this is your executable) the rest is the apline image. (Node apline image is 116MB)<ol><li><code>make size_compressed</code> - This will give you the gzipped image size which should be comparable to what youâ€™d pull from a registry.</ol><p>The compressed size comes in at <strong>21mb</strong>, the node.js apline image by comparison is 38.93 MB<ol><li><code>make run</code> - run the server.</ol><p>My little experience with deno has been very positive so far. I really like how itâ€™s cleaning up typescript & javascriptâ€™s disparate ecosystem and creating a uniform toolkit for building software.<p>Next Iâ€™m looking forward to try out their built in test framework too see how that fairs against more established things like jest.